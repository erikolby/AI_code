diagnose_function <- function(network, cases) {
  # Do not forgett the burnout period!! Ie. Discard the 100 or so first samples generated by my MCMC Metropolis in Gibbs algorithm. 
  
  random_values <- runif(10000) # can be made more or less depending on how many I need, just took an abitrary number. 
  output_matrix <- matrix(rep(1,40), ncol = 4)
  # The MCMC Metropolis in Gibbs algorithm: 
  working_array <- numeric(9)
  
  assign_0_or_1 <- function(random_values, random_number_index) {
    if (sample(random_values,1) > 0.5) {
      return(1)
    }
    else {
      return(0)
    }
  }
  
  for (i in 1:10) {
    
    # Load the working array:
    for (j in 1:9) {
      working_array[j] <- cases[i,j]
    }
    
    # assign the unknown variables with a random value: 
    working_array[1] <- assign_0_or_1(random_values)
    working_array[4] <- assign_0_or_1(random_values)
    working_array[6] <- assign_0_or_1(random_values)
    working_array[7] <- assign_0_or_1(random_values)
    
    # Calculating the contitional attributes, unsure about how to find probability of temp!!: 
    calc_p_value <- function(network, working_array) {
      Pn_old <- network$Pn[[working_array[1]+1]]
      temp_old <- dnorm(working_array[2], network$temperature[[working_array[1]+1]][1], 
                      network$temperature[[working_array[1]+1]][2])
      VTB_old <- network$VTB[[working_array[3]+1]]
      TB_old <- network$TB[[working_array[3]+1]][working_array[4]+1]
      Smoke_old <- network$smokes[[working_array[5]+1]]
      LC_old <- network$LC[[working_array[5]+1]][working_array[6]+1]
      Br_old <- network$BR[[working_array[5]+1]][working_array[7]+1]
      Xray_old <- network$Xray[[working_array[1]+1]][[working_array[4]+1]][[working_array[6]+1]][working_array[8]+1]
      Dy_old <- network$Dy[[working_array[6]+1]][[working_array[7]+1]][working_array[9]+1]
    
      P_old <- Pn_old*temp_old*VTB_old*TB_old*Smoke_old*LC_old*Br_old*Xray_old*Dy_old
      return(P_old)
    }
    P_comparision <- function(network, working_array, investigated_index) {
      proposed_value <- 0
      old_value <- working_array[investigated_index]
      if (working_array[investigated_index] == 0) {
        proposed_value <- 1
      }
    
      P_old <- calc_p_value(network, working_array)
      working_array[investigated_index] <- proposed_value
      P_new <- calc_p_value(network, working_array)
    
      if (P_new < P_old) {
        working_array[investigated_index] <- old_value
      }
      return(working_array)
    }
    
    for (k in 1:1000) {
    # After this one MCMC Metropolis in Gibbs sample has been generated: 
    working_array <- P_comparision(network, working_array, 1)
    working_array <- P_comparision(network, working_array, 4)
    working_array <- P_comparision(network, working_array, 6)
    working_array <- P_comparision(network, working_array, 7)
    }
    
    output_matrix[i,] <- c(working_array[1], working_array[4], working_array[6], working_array[7])
    
  }
  
  return(output_matrix)
  
  
}